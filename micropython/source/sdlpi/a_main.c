#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <stdint.h>
#include <SDL.h>


#include "../kernel/platform.h"
#include "../kernel/wiring.h"

#include "py/nlr.h"
#include "py/stackctrl.h"
#include "py/compile.h"
#include "py/runtime.h"
#include "py/repl.h"
#include "py/gc.h"
#include "py/mphal.h"
#include "lib/readline.h"
#include "lib/utils/pyexec.h"


#include "genhdr/mpversion.h"

#include "mphalport.h"

#define FONT                    vgafont8
#define BIT_SHIFT               (7 - s_bit_no)

#define CHAR_W                  8
#define CHAR_H                  8

static unsigned char vgafont8[128 * 8]= {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
    0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
    0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
    0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
    0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
    0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
    0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
    0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
    0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
    0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
    0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
    0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
    0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
    0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
    0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
    0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
    0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
    0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
    0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
    0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
    0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
    0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
    0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
    0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
    0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
    0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
    0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
    0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
    0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
    0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
    0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
    0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
    0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
    0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
    0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
    0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
    0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
    0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
    0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
    0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
    0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
    0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
    0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
    0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
    0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
    0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
    0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
    0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
    0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
    0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
    0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
    0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
    0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
    0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
    0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
    0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
    0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
    0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
    0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
    0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
    0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
    0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
    0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
    0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
    0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
    0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
    0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
    0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
    0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
    0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
    0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
    0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
    0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
    0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
    0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
    0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
    0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
    0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
    0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
    0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
    0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
    0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
    0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
    0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
    0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
    0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
    0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
    0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
    0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
    0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
    0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
    0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
    0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
    0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
    0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
    0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
    0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
    0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
    0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
    0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
    0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
    0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
    0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
    0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
    0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
    0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
    0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
};

static unsigned char keyNormal_it[] = {
    0x0, 0x0, 0x0, 0x0, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
    'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2',
    '3', '4', '5', '6', '7', '8', '9', '0', '\r', 27, '\b', '\t', ' ', '-', '=', '[',
    ']', '\\', 0x0, ';', '\'', 0x0, ',', '.', '/', 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, '/', '*', '-', '+', '\r', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', '0', '.', '<', 0x0, 0x0, '='
};

static unsigned char keyShift_it[] = {
    0x0, 0x0, 0x0, 0x0, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
    'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '!', '@',
    '#', '$', '%', '^', '&', '*', '(', ')', '\r', 27, '\b', '\t', ' ', '_', '+', '{',
    '}', '|', 0x0, ':', '"', '|', '<', '>', '?', 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, '/', '*', '-', '+', '\r', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', '0', '.', '>', 0x0, 0x0, '='
};

#if defined(__cplusplus)
extern "C" {
#endif

__attribute__ ((interrupt ("IRQ"))) void interrupt_irq() {
    SDL_Interrupt_Handler();
}

#if defined(__cplusplus)
}
#endif


static SDL_Rect crect;

void SDL_InitConsole(int w, int h) {
    crect.x = (w - txt_width * CHAR_W) / 2;
    crect.y = (h - txt_height * CHAR_H) / 2;
    crect.w = txt_width * CHAR_W;
    crect.h = txt_height * CHAR_H;

    for (int i = 0; i < txt_width * txt_height; i++) {
        screen[i].c = ' ';
        screen[i].fore.r = 255;
        screen[i].fore.g = 255;
        screen[i].fore.b = 255;
        screen[i].back.r = 98;
        screen[i].back.g = 0;
        screen[i].back.b = 32;
    }

    cur_x = 0;
    cur_y = 0;
}

void SDL_RenderConsole(SDL_Renderer *renderer) {
    int x, y, c_x;
    int index = 0;

    for (y = crect.y; index < txt_width * txt_height; y += CHAR_H) {
        for (c_x = 0, x = crect.x; c_x < txt_width && index < txt_width * txt_height; index++, c_x++, x += CHAR_W) {
            int s_offset = (int) screen[index].c * CHAR_W * CHAR_H;
            for (int f_y = 0; f_y < CHAR_H; f_y++) {
                for (int f_x = 0; f_x < CHAR_W; f_x++) {
                    int s_byte_no = s_offset / 8;
                    int s_bit_no = s_offset % 8;

                    unsigned char s_byte = FONT[s_byte_no];
                    if ((s_byte >> BIT_SHIFT) & 0x1)
                        SDL_SetRenderDrawColor(renderer, screen[index].fore.r, screen[index].fore.g, screen[index].fore.b, 255);
                    else
                        SDL_SetRenderDrawColor(renderer, screen[index].back.r, screen[index].back.g, screen[index].back.b, 255);
                    SDL_RenderDrawPoint(renderer, x + f_x, y + f_y);
                    s_offset++;
                }
            }
        }
    }

    if (cursor_visible) {
        SDL_Rect rect;
        rect.x = crect.x + cur_x * CHAR_W;
        rect.y = crect.y + cur_y * CHAR_H;
        rect.w = CHAR_W;
        rect.h = CHAR_H;
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &rect);
    }
}


SDL_Renderer *renderer;
SDL_Event event;
struct timer_wait tw;
int led_status = LOW;

void flash_cursor()
{
    
    if (compare_timer(&tw)) {
        led_status = led_status == LOW ? HIGH : LOW;
        digitalWrite(16, led_status);
        cursor_visible = cursor_visible ? 0 : 1;
    }
}
void render()
{
    
    SDL_SetRenderDrawColor(renderer, 213, 41, 82, 255);
    SDL_RenderClear(renderer);
    
    SDL_RenderConsole(renderer);
    
    SDL_RenderPresent(renderer);
}

void mp_keyboard_interrupt(void) {
   // MP_STATE_VM(mp_pending_exception) = MP_STATE_PORT(mp_kbd_exception);
}

static char *stack_top;


// for gc_init
void gc_collect(void) {
    // WARNING: This gc_collect implementation doesn't try to get root
    // pointers from CPU registers, and thus may function incorrectly.
    void *dummy;
    gc_collect_start();
    gc_collect_root(&dummy, ((mp_uint_t)stack_top - (mp_uint_t)&dummy) / sizeof(mp_uint_t));
    gc_collect_end();
    // gc_dump_info();
}


mp_lexer_t *mp_lexer_new_from_file(const char *filename) {
    (void)filename;
    return NULL;
}

mp_import_stat_t mp_import_stat(const char *path) {
    (void)path;
    return MP_IMPORT_STAT_NO_EXIST;
}

mp_obj_t mp_builtin_open(uint n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    (void)n_args;
    (void)args;
    (void)kwargs;
    return mp_const_none;
}
MP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_open_obj, 1, mp_builtin_open);

void nlr_jump_fail(void *val) {
    (void)val;
}


// end gc_init requirements




int main() {
    int w, h;
    SDL_Window *screen = 0;

    SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_EVENTS);

    // Default screen resolution (set in config.txt or auto-detected)
    //SDL_CreateWindowAndRenderer(0, 0, SDL_WINDOW_FULLSCREEN_DESKTOP, &screen, &renderer);

#if !(MACOS_SDLMP)
    // Sets a specific screen resolution
    SDL_CreateWindowAndRenderer(32 + 320 + 32, 32 + 200 + 32, SDL_WINDOW_FULLSCREEN, &screen, &renderer);
#else
    // NOTE: It shouldn't be possible to change the window and render in this OS
    SDL_CreateWindowAndRenderer(32 + 320 + 32, 32 + 200 + 32, SDL_WINDOW_RESIZABLE, &screen, &renderer);
#endif
    
    SDL_GetWindowSize(screen, &w, &h);
    SDL_InitConsole(w, h);

    SDL_DrawStringAtA(1, (txt_width - 22) / 2, "**** RASPBERRY-PI ****");
    SDL_DrawStringAtA(3, (txt_width - 30) / 2, "BARE-METAL SDL SYSTEM TEMPLATE\r\n");

    pinMode(16, OUTPUT);
    register_timer(&tw, 250000);

    SDL_DrawStringA("\r\nREADY\r\n");


    int stack_dummy;
    stack_top = (char*)&stack_dummy;

    
    mp_stack_ctrl_init();
    mp_stack_set_limit(1800); // stack is 2k


    // allocate the heap statically in the bss
    static uint32_t heap[9820 / 4];
    gc_init(heap, (uint8_t*)heap + sizeof(heap));

    
    mp_init();
    mp_hal_init();
//    readline_init0();

// MICROPY_REPL_EVENT_DRIVEN
    pyexec_event_repl_init();

// something wrong here - default set to FRIENDLY
    // if (pyexec_mode_kind == PYEXEC_MODE_FRIENDLY_REPL) {
    //     // from microbit import *
    //     mp_import_all(mp_import_name(MP_QSTR_microbit, mp_const_empty_tuple, MP_OBJ_NEW_SMALL_INT(0)));
    // }
    bool done = false;
    while(!done) {


        // SORT OUT THE KEYS!

        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_KEYDOWN) {
                //printf("keycode %d\n",event.key.keysym.scancode);
                switch(event.key.keysym.scancode) {
                        // F12 to quit
                    case SDL_SCANCODE_F12:
                        done = true;
                        break;
                    case SDL_SCANCODE_DELETE:
                        SDL_SetChar(127);
                        break;
                    case SDL_SCANCODE_BACKSPACE:
                    case SDL_SCANCODE_KP_BACKSPACE:
                        SDL_SetChar(8);
                        break;
                    case SDL_SCANCODE_TAB:
                    case SDL_SCANCODE_KP_TAB:
                        SDL_SetChar(9);
                        break;
                    case SDL_SCANCODE_UP:
                        SDL_SetChar(CHAR_CTRL_P);
                        break;
                    case SDL_SCANCODE_DOWN:
                        SDL_SetChar(CHAR_CTRL_N);
                        break;
                    case SDL_SCANCODE_LEFT:
                        SDL_SetChar(CHAR_CTRL_B);
                        break;
                    case SDL_SCANCODE_RIGHT:
                        SDL_SetChar(CHAR_CTRL_F);
                        break;
                    case SDL_SCANCODE_HOME:
                        SDL_SetChar(CHAR_CTRL_A);
                        break;
                    case SDL_SCANCODE_END:
                        SDL_SetChar(CHAR_CTRL_E);
                        break;
                    case SDL_SCANCODE_RETURN:
                        SDL_SetChar('\r');
                        break;
                    case SDL_SCANCODE_ESCAPE:
                        SDL_SetChar(27);
                        break;
                    default: {
                        SDL_Keymod mod = SDL_GetModState();
                        if ((mod & (KMOD_LCTRL | KMOD_RCTRL)) != 0) {
                            switch(event.key.keysym.scancode) {
                                case SDL_SCANCODE_C:
                                    SDL_SetChar(CHAR_CTRL_C);
                                    break;
                                default:
                                    break;
                            }
                        }
                        else if ((mod & (KMOD_LSHIFT | KMOD_RSHIFT)) != 0) {
                            if (event.key.keysym.scancode <= sizeof(keyShift_it)/sizeof(unsigned char))
                            {
                            char c = keyShift_it[event.key.keysym.scancode];
                            if (c >= ' ')
                                   SDL_SetChar(c);
                            }
                        }
                        else {
                            if (event.key.keysym.scancode <= sizeof(keyNormal_it)/sizeof(unsigned char))
                            {
                            char c = keyNormal_it[event.key.keysym.scancode];
                            if (c >= ' ')
                                   SDL_SetChar(c);
                            }
                        }
                        break;
                    }
                }
                
                int c = mp_hal_stdin_rx_chr();
                if (pyexec_event_repl_process_char(c)) {
                    done = 1;
                }

            }
            else if (event.type == SDL_QUIT)
            {
                done = true;
            }
        }


        // now sort out python
        // MICROPY_REPL_EVENT_DRIVEN
//        int ret = 0;
//        int interrupt_char = CHAR_CTRL_C;
//        int c = mp_hal_stdin_rx_chr();
//        if (c == interrupt_char) {
//            mp_keyboard_interrupt();
//        }
//        ret = pyexec_event_repl_process_char(c);
//        if (ret & PYEXEC_FORCED_EXIT) {
//            done = true;
//        }

        // now sort out display
        flash_cursor();
        render();

    }

    mp_hal_stdout_tx_str("soft reboot\r\n");

    memset(&MP_STATE_PORT(async_data)[0], 0, sizeof(MP_STATE_PORT(async_data)));
    MP_STATE_PORT(async_music_data) = NULL;

    mp_deinit();

    return 0;
}
